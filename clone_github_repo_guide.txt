Step 1: Generate an SSH Key on the EC2 Instance
First, create a new SSH key pair on your EC2 instance. Do this under the user account that will run the deployment (e.g. the default ec2-user or ubuntu account), not as root. Using a dedicated key ensures security and easy management. For example, generate an Ed25519 key (modern and secure) with no passphrase (since this key will be used in automation):
bash
Copy
Edit
# On the EC2 instance, generate a new SSH key pair
ssh-keygen -t ed25519 -C "GitHub deploy key for <repo-name>"
When prompted for a file path, press Enter to accept the default (e.g. ~/.ssh/id_ed25519). You can also specify a file with the -f option (e.g. -f ~/.ssh/<deploy-key-filename>).
Do not enter a passphrase when prompted (just press Enter) – leaving it empty allows automation without interactive password entry.
This produces two files in ~/.ssh/: a private key (e.g. id_ed25519) and a public key (e.g. id_ed25519.pub). The public key contains a single line starting with ssh-ed25519 (or ssh-rsa if you used RSA).
Secure the key files: ensure the private key is readable only by your user. Typically, ssh-keygen sets correct permissions, but you can double-check with:
bash
Copy
Edit
chmod 600 ~/.ssh/id_ed25519
chmod 644 ~/.ssh/id_ed25519.pub
The private key (id_ed25519) should be kept secret and never shared. It will be used by the EC2 instance to authenticate to GitHub. The public key (id_ed25519.pub) will be added to GitHub in the next step.
Step 2: Add the Public Key to GitHub as a Deploy Key
To allow GitHub to trust your EC2’s key, add the public key to your repository as a Deploy Key. Deploy keys grant access to a single repo (unlike personal SSH keys which grant access to all your repos)
dev.to
. This principle of least privilege is more secure for automation.
Copy the public key: On the EC2, output the public key and copy its contents. For example:
bash
Copy
Edit
cat ~/.ssh/id_ed25519.pub
It will look like ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI... [email@example.com]. Make sure you copy everything from ssh-ed25519 up to the email/comment.
Add the key on GitHub: Log in to GitHub and navigate to your repository (the private repo you want to pull). Go to Settings > Deploy Keys and click "Add deploy key".
Give it a title like “EC2 Deploy Key” (for your reference).
Paste the public key text into the key field.
For permissions: If the EC2 only needs to clone/pull (read-only), leave "Allow write access" unchecked
dev.to
. (Only check this if the deployment process needs to push changes back, which is uncommon for pull-only deployment.)
Save the deploy key.
Once added, GitHub will now recognize your EC2’s key and allow it to access that repository. Remember: A deploy key is specific to one repository and isn’t tied to your personal account
dev.to
. If you have multiple private repos to access, you will need to add a deploy key for each, using a unique key pair per repo (GitHub does not allow reusing the exact same key on multiple repos)
stackoverflow.com
.
Step 3: Test SSH Connection and Clone the Repository
Back on the EC2 instance, test that the SSH authentication to GitHub works:
bash
Copy
Edit
# This test doesn't provide shell access but will confirm the key is recognized
ssh -T git@github.com
On the first connection, you may see a prompt about host authenticity (GitHub’s SSH host key). Verify and accept the host key so that it’s added to ~/.ssh/known_hosts. You can manually accept by typing “yes” at the prompt, or pre-add GitHub’s host key using:
bash
Copy
Edit
# Add GitHub's server key to known_hosts (to avoid interactive prompt)
ssh-keyscan -H github.com >> ~/.ssh/known_hosts
(Optional: For security, you can cross-check the fingerprint of the key added with GitHub’s published SSH key fingerprints
docs.github.com
.) The ssh -T command should output a message from GitHub, e.g. “Hi [username]! You've successfully authenticated...” (or a generic success message). This confirms that the private key on EC2 is properly configured and recognized by GitHub. If you get “Permission denied (publickey)”, double-check that the public key was added to the repo’s deploy keys and that you’re using the correct EC2 user (with the key in its ~/.ssh). Now, clone the private repository using the SSH URL. Navigate to or decide on a directory where you want the code. For example, to clone into /home/ubuntu/myapp:
bash
Copy
Edit
# Clone the repository to a directory (replace repo URL with your own)
git clone git@github.com:<GitHub-Username>/<RepoName>.git /home/ubuntu/myapp
Use the git@github.com:owner/repo.git style URL (this is the SSH path). Do not use the HTTPS URL, as that would require a username/token.
If you omit the target directory, Git will create a folder named after the repo. In our example, we explicitly set /home/ubuntu/myapp as the target directory.
If prompted again about host key authenticity, confirm as in the previous step.
After cloning, you should have the repository files on the EC2 instance. You can run git pull inside that directory to ensure everything is up-to-date (later, this is what we will automate).
Step 4: Automate Regular Pulls from GitHub
With SSH access set up and the repo cloned, you can automate pulling the latest changes. This ensures your deployment stays current with the repository. Two simple methods are using a Cron job or a systemd timer. Use one of these methods (whichever you are more comfortable with):
Option 1: Scheduling with Cron
Cron is a classic way to run commands periodically. You can have the EC2 instance pull the repo at regular intervals (e.g. every 5 minutes, every hour, etc.).
Edit the crontab for the user that owns the repo files (e.g. ec2-user or ubuntu). Run:
bash
Copy
Edit
crontab -e
This will open an editor for the cron schedule.
Add a cron entry to pull the repository. For example, to pull every 15 minutes, you could add:
bash
Copy
Edit
*/15 * * * * cd /home/ubuntu/myapp && git pull origin main >> /home/ubuntu/git-pull.log 2>&1
This line means: every 15 minutes, change directory to the repo and run git pull origin main. Output (stdout and stderr) is appended to a log file for debugging (git-pull.log), which you can omit or redirect to /dev/null if not needed.
Adjust the schedule as needed. The format is min hour day month weekday command. For example, 0 * * * * would run hourly on the hour, 0 0 * * * would run daily at midnight, etc.
Ensure the cd path is correct for your clone, and specify the right branch (main or master or whatever branch you deploy from).
Using the full path to git (e.g. /usr/bin/git) is not usually necessary, but if you run into PATH issues in cron, specify the full path or define PATH at the top of the crontab.
Save and exit the crontab editor. Cron will automatically start running the job at the specified intervals.
Cron will now periodically execute git pull. If there are new commits, they will be fetched and merged into your local checkout. This keeps your code up-to-date without manual intervention. Tips for cron jobs:
Make sure the cron job is running as the same user that has the SSH key and clone. If you accidentally put it in root’s crontab while the key is in ubuntu’s .ssh, the pull will fail due to missing key. One way to ensure this is to use the user’s crontab (as shown with crontab -e when logged in as that user).
If the repository updates involve restarting services or additional deployment steps, you can chain those in the cron command (after git pull && ...) or call a script.
Keep an eye on the git-pull.log (if you set one) to catch errors. For example, "Host key verification failed" or "Permission denied" messages would indicate issues that need attention (see Pitfalls below).
Option 2: Scheduling with a systemd Timer (Alternative)
If your EC2 instance uses systemd (most modern Linux distributions do), you can use a systemd timer as an alternative to cron. Systemd timers can be easier to manage as part of your infrastructure code and integrate with system logs. Create a systemd service unit to perform the git pull. For example, create a file /etc/systemd/system/git-pull.service with the following content (adjust paths and user):
ini
Copy
Edit
[Unit]
Description=Pull latest code for MyApp from GitHub

[Service]
Type=oneshot
# User and WorkingDirectory should be the owner of the repo and its path
User=ubuntu
WorkingDirectory=/home/ubuntu/myapp
ExecStart=/usr/bin/git pull origin main
This defines a one-time service that simply runs git pull in the repo directory. Create a timer unit /etc/systemd/system/git-pull.timer to schedule the service:
ini
Copy
Edit
[Unit]
Description=Schedule regular Git pulls for MyApp

[Timer]
OnBootSec=5min           # Wait 5 minutes after boot before first run
OnUnitActiveSec=15min    # Run every 15 minutes
Persistent=true          # Catch up if the system was off during a scheduled time

[Install]
WantedBy=timers.target
This timer will trigger the git-pull.service 5 minutes after boot and then every 15 minutes thereafter. (Adjust the interval as needed using OnUnitActiveSec or use OnCalendar for specific times.) Enable and start the timer:
bash
Copy
Edit
sudo systemctl daemon-reload               # pick up the new unit files
sudo systemctl enable --now git-pull.timer # enable at startup and start it now
You can check status with systemctl status git-pull.timer and systemctl status git-pull.service to ensure it ran. The output of the git pull will go to the systemd journal (viewable via journalctl -u git-pull.service). Systemd will handle ensuring the job runs at the requested times (even if the machine was asleep/off, thanks to Persistent=true). Cron vs systemd: Both accomplish the task. Cron is simpler to set up via one-line configuration, while systemd provides more control (logging, dependency management). For a basic pull every X minutes, cron is perfectly fine; if you prefer integration with system services or need more complex schedules, systemd timers are a robust option.
Step 5: Secure Key Management and Access Permissions
Security is paramount when accessing a private repo. Here are important practices to keep the process secure:
Use Deploy Keys for Minimal Access: The SSH key you added is a deploy key, which grants access to only that one repository on GitHub
dev.to
. This is more secure than using a personal SSH key that grants access to all your repos. If the server or key is compromised, attackers only gain access to that single repo.
Read-Only Access (Least Privilege): Keep the deploy key read-only unless you explicitly need to push from the server. By default, deploy keys do not have write permission, which is ideal for pulling code
dev.to
. Only enable write access if your automation must push changes (rare in deployment scenarios).
Protect the Private Key: Treat the private key file on the EC2 like a password:
Ensure its permissions are 600 (owner-read/write only). SSH will refuse to use the key if it’s accessible by others for security reasons.
Do not expose the key in scripts, logs, or backups that aren’t secure. For example, avoid printing it or embedding it directly in user-data scripts. Keep it in ~/.ssh/ and share it with no one
dev.to
.
If possible, use a dedicated user account on the EC2 for pulling the repo, and restrict that account’s privileges on the system.
SSH Config (if needed): Typically, placing the key as a default ~/.ssh/id_ed25519 (or id_rsa) is enough. SSH will use it automatically. If you used a non-standard filename or have multiple keys, you can configure ~/.ssh/config to specify which key to use for GitHub:
ini
Copy
Edit
Host github.com
    IdentityFile ~/.ssh/your_private_key_file
    IdentitiesOnly yes
This ensures the correct key is used for GitHub operations. (This is only needed if you deviated from default key names or manage many keys.)
Verify Host Keys: As noted, always verify GitHub’s host key on first connection. This prevents man-in-the-middle attacks. It’s better to add the known host key than to use insecure options like StrictHostKeyChecking=no in scripts (which would skip verification entirely). Once the host key is in known_hosts, automated pulls will run without prompts and still verify the server’s identity.
GitHub Access Control: Remember that deploy keys are per-repo. Do not reuse the same key on multiple repositories
stackoverflow.com
dev.to
. GitHub disallows using the exact same deploy key on more than one repo for security. If you need one server to access several repos, either add multiple deploy keys (one per repo) or consider using a machine user (a separate GitHub user account with SSH keys or personal access token) that has read access to those repos
dev.to
. The machine-user approach can be useful for complex setups, but for a single repo, deploy keys are simplest.
Common Pitfalls and Troubleshooting
Even with the above setup, a few issues can occur. Here are common pitfalls and how to address them:
SSH Key Permissions or Ownership: If git pull (especially via cron) fails with an SSH error, the cause is often improper permissions or the wrong user. For example, if the cron job runs as root but the key is in another user’s .ssh, it won’t be accessible. Ensure the cron job runs under the correct user, and that the private key file is only accessible by that user. In some cases, a cron job might not have the user’s SSH agent or home env, leading to “permission denied” errors
blog.justtom.com
. Running the job as the user (not root) and using the default key location alleviates this.
“Host key verification failed”: This means the GitHub host key is unknown or has changed. It will block the connection for safety. To fix this, add GitHub’s host key to the ~/.ssh/known_hosts (as shown in Step 3). If it changed (e.g., GitHub rotated keys), update the entry. Avoid using StrictHostKeyChecking=no in production scripts, as it can expose you to man-in-the-middle attacks.
“Permission denied (publickey)”: This indicates SSH authentication failed. Possible reasons: The deploy key wasn’t added to GitHub correctly, or you’re using the wrong key. Verify the public key is indeed in the repo’s Deploy Keys list. Ensure the EC2 is using the corresponding private key. You can test with ssh -T git@github.com manually. If you generated the key with a custom name, you might need to load it (ssh-add ~/.ssh/your_key) or specify it in SSH config so that Git uses it.
Cron Job Not Running or No Git in PATH: If it seems nothing is happening, make sure cron is active and your crontab entry is correct (cron entries require a newline at end of file, and the schedule syntax must be valid). Cron uses a limited default PATH; if the git command isn’t found, specify the full path or set a PATH in the crontab. You can test your cron command by running it manually in a shell. Also check that the cron service is running on the system.
Merge conflicts or local changes: If someone edits files on the server or if your deployment process modifies files in the repo directory, a git pull may fail due to conflicts. For a purely pull-based deployment, avoid editing tracked files on the server. If you need to, consider a force pull strategy (like git fetch && git reset --hard origin/<branch>) but be cautious – that will discard local changes. It’s best if the repo on the server is a clean copy that is only updated via pulls. Then git pull will fast-forward without issues. Using git pull --ff-only is another strategy to prevent unintended merges.
Scheduling frequency and overlap: Don’t run the pull job too frequently without need. Every minute might be overkill unless you need near-instant updates. Also, if using systemd timers, it will prevent overlapping runs by default (the job is oneshot), but with cron, if you set an extremely short interval and a pull takes long, you could end up with overlapping executions. In most cases, a pull is quick; just be mindful if your deploy step involves heavy work (you might want to ensure the previous run finished, or use a lock file).
Multiple repositories or environments: As mentioned, one deploy key = one repo. If your EC2 needs to pull from multiple private repos, you’ll need to repeat the key setup for each (and use different key files or a consolidated approach). A common mistake is trying to reuse the same deploy key on another repo – GitHub will refuse with an error because each key fingerprint must be unique in GitHub’s database
stackoverflow.com
. Instead, generate a new key for the second repo, or use a single SSH key tied to a machine user that has access to both repos (less restrictive, so only do this if managing many repos).
By following this guide, your EC2 instance should securely authenticate to GitHub and regularly pull the latest code from your private repository. You’ve set up a reliable, automated deployment fetch mechanism using just SSH keys and built-in scheduling tools. Always monitor the first few runs (check the logs or output) to ensure everything is working, and enjoy your streamlined deployment process!